# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Linear interpolation of genetic map values
#'
#' @param map  is a length `p` vector of cumulative genetic map values. `map` must be _strictly_ _sorted_
#' @param map_pos  is a length `p` vector of genome coordinates corresponding to the reference genetic map. `map_pos` must be _strictly_ _sorted_
#' @param target_pos is a vector of coordinates to interpolate
#' @param strict a boolean indicating whether to strictly interpolate
#' @param progress a boolean indicating whether to indicate progress with a progress bar
#'
#' @export
interpolate_genetic_map <- function(map, map_pos, target_pos, strict = TRUE, progress = FALSE) {
    .Call('_ldmap_interpolate_genetic_map', PACKAGE = 'ldmap', map, map_pos, target_pos, strict, progress)
}

parse_ldmap_range <- function(input) {
    .Call('_ldmap_parse_ldmap_range', PACKAGE = 'ldmap', input)
}

parse_ldmap_SNP <- function(input) {
    .Call('_ldmap_parse_ldmap_SNP', PACKAGE = 'ldmap', input)
}

#' Creation of new ldmap_ranges
#'
#' @param chrom an integer vector of chromosomes
#' @param start an integer vector of start positions
#' @param stop an integer vector of stop positions
#' @export
new_ldmap_range <- function(chrom = as.integer( c()), start = as.integer( c()), end = as.integer( c())) {
    .Call('_ldmap_new_ldmap_range', PACKAGE = 'ldmap', chrom, start, end)
}

#' Assign ranges to nearest ranges
#'
#' @param query vector of query ldmap_snps
#' @param target vector of target ldmap_snps (must be sorted)
#' @return a vector of integers of length `length(ldmap_range_query)` with the index of the `ldmap_range_target`
#' @export
nearest_snp_range <- function(query, target) {
    .Call('_ldmap_nearest_snp_range', PACKAGE = 'ldmap', query, target)
}

#' Assign ranges to ranges
#'
#' @param ldmap_range_query vector of ldmap_ranges
#' @param ldmap_range_target vector of *non-overlapping* ldmap_ranges (must be sorted)
#' @param allow_overlap is it alright if a query is only partially inside the target?
#' @return a vector of integers of length `length(ldmap_range_query)` with the index of the `ldmap_range_target`
#' @export
range_in_range <- function(ldmap_range_query, ldmap_range_target, allow_overlap = FALSE) {
    .Call('_ldmap_range_in_range', PACKAGE = 'ldmap', ldmap_range_query, ldmap_range_target, allow_overlap)
}

#' Assign SNPs to ranges
#'
#' @param ldmap_snp vector of ldmap_snps (must be sorted)
#' @param ldmap_range vector of non-overlapping ldmap_ranges (must be sorted)
#' @return a vector of integers of length `length(ldmap_snp)` with the index of the `ldmap_range`
#' @export
snp_in_range <- function(ldmap_snp, ldmap_range) {
    .Call('_ldmap_snp_in_range', PACKAGE = 'ldmap', ldmap_snp, ldmap_range)
}

#' Assign SNPs to ranges
#'
#' @param ldmap_snp vector of ldmap_snps (must be sorted)
#' @param ldmap_range vector of non-overlapping ldmap_ranges (must be sorted)
#' @return a vector of integers of length `length(ldmap_snp)` with the index of the `ldmap_range`
#' @export
snp_in_ranges <- function(ldmap_snp, ldmap_ranges) {
    .Call('_ldmap_snp_in_ranges', PACKAGE = 'ldmap', ldmap_snp, ldmap_ranges)
}

#' formatting of ldmap_ranges
#'
#' @param x an ldmap_range
#' @export
format_ldmap_range <- function(x) {
    .Call('_ldmap_format_ldmap_range', PACKAGE = 'ldmap', x)
}

#' Assign SNPs to ranges
#'
#' @param ldmap_snp vector of ldmap_snps (must be sorted)
#' @param ldmap_range vector of potentially overlapping ldmap_ranges (must be sorted)
#' @return a list of integer vectors giving the ranges to which each SNP belongs
#' @export
match_ranges_snps <- function(df, ldmap_range, snp_col = "snp_struct") {
    .Call('_ldmap_match_ranges_snps', PACKAGE = 'ldmap', df, ldmap_range, snp_col)
}

#' Create overlapping regions based on monotonic, point-level annotation
#'
#' @param ldmap_snp a (sorted) ldmap_snp vector (`length(ldmap_snp)` is referred to  as  `p`)
#' @param cm a numeric vector of (length `p`) per-snp annotations (e.g cumulative recombination rate)
#' @param window the window width.
#'
#' @return a vector of `ldmap_range`s of length `p` giving the window for each SNP.  The width of the window
#' is defined for a target snp `ldmap_snp[i]`, as having the chromosome
#' from `ldmap_snp[i]` and including the position of all `ldmap_snp[j]` snps such that `abs(cm[i]-cm[j])<window` for all values of `j`
#' @export
window_ldmap_range <- function(ldmap_snp, cm, window = 1.0) {
    .Call('_ldmap_window_ldmap_range', PACKAGE = 'ldmap', ldmap_snp, cm, window)
}

#' Take a vector of (preferably) sorted and (possibly) overlapping ldmap_ranges and create a new range of (sorted) non-overlapping ldmap_ranges
#'
#' @param x a (preferably sorted) ldmap_range vector (`length(x)` is referred to  as  `p`)
#'
#' @export
#' @return a sorted vector ldmap_ranges of length at least `p` and at most `2p`(?) representing the same intervals
split_ldmap_range_overlap <- function(x) {
    .Call('_ldmap_split_ldmap_range_overlap', PACKAGE = 'ldmap', x)
}

#' Merge two ldmap_range vectors
#'
#' @param x a (preferably sorted) ldmap_range vector (`length(x)` is referred to  as  `p`)
#' @param y a (preferably sorted) ldmap_range vector (`length(y)` is referred to  as  `q`)
#'
#' @return a sorted vector ldmap_ranges of length at most `p+q` and at least `max(p,q)` representing the union of the two sets of ranges
#' @export
merge_ldmap_ranges <- function(x, y) {
    .Call('_ldmap_merge_ldmap_ranges', PACKAGE = 'ldmap', x, y)
}

#' convert ldmap_range to dataframe
#'
#' @param ldmap_range an ldmap_range
#' @export
ldmap_range_2_data_frame <- function(ldmap_range) {
    .Call('_ldmap_ldmap_range_2_data_frame', PACKAGE = 'ldmap', ldmap_range)
}

sample_interval <- function(n, beginv, endv, replace = FALSE) {
    .Call('_ldmap_sample_interval', PACKAGE = 'ldmap', n, beginv, endv, replace)
}

#' Creation of new ldmap_snps
#'
#' @param chrom an integer vector of chromosomes
#' @param pos a double vector of positions
#' @param ref an optional vector of reference allele (see `?new_ldmap_allele`)
#' @param alt an optional vector of alternate allele (see `?new_ldmap_allele`)
#' @param NA2N an optional boolean specifying whether missing/NA alleles should be treated as "N"
#'
#' @export
new_ldmap_snp <- function(chrom = as.integer( c()), pos = as.numeric( c()), ref = as.integer( c()), alt = as.integer( c()), NA2N = FALSE) {
    .Call('_ldmap_new_ldmap_snp', PACKAGE = 'ldmap', chrom, pos, ref, alt, NA2N)
}

#' Which SNPs are strand ambiguous
#'
#' @param x the ldmap_snp struct
#'
#' @export
is_strand_ambiguous <- function(x) {
    .Call('_ldmap_is_strand_ambiguous', PACKAGE = 'ldmap', x)
}

#' Convert allele info to ldmap_alleles
#'
#' @param allele vector of alleles, coded either as character, integer or raw
#'
#' @export
new_ldmap_allele <- function(allele = as.integer( c())) {
    .Call('_ldmap_new_ldmap_allele', PACKAGE = 'ldmap', allele)
}

#' sorting method for ldmap snps
#'
#' @param struct_vec the vector of SNPs
#'
#' @method order ldmap_snp
#' @export
#' @export order.ldmap_snp
order.ldmap_snp <- function(struct_vec) {
    .Call('_ldmap_order_snps', PACKAGE = 'ldmap', struct_vec)
}

#' ranking method for ldmap snps
#'
#' @param struct_vec the vector of SNPs
#'
#' @method rank ldmap_snp
#' @export
#' @export rank.ldmap_snp
rank.ldmap_snp <- function(struct_vec) {
    .Call('_ldmap_rank_snps', PACKAGE = 'ldmap', struct_vec)
}

#' get chroms from a ldmap_snp
#'
#' @param struct_vec the vector of SNPs (or ldmap_ranges)
#'
#' @export
chromosomes <- function(struct_vec) {
    .Call('_ldmap_chromosomes', PACKAGE = 'ldmap', struct_vec)
}

#' get starting position from a ldmap_range
#'
#' @param ldmap_range the vector of ldmap_ranges
#'
#' @export
starts <- function(ldmap_range) {
    .Call('_ldmap_starts', PACKAGE = 'ldmap', ldmap_range)
}

#' Find convex hull of vector of ranges (or SNPs )
#'
#' @param vector of ldmap_range or ldmap_snp of 
#' @return an ldmap range containg all the ranges (or snps)
#'
#' @export
convex_hull <- function(x) {
    .Call('_ldmap_convex_hull', PACKAGE = 'ldmap', x)
}

#' get end position from a ldmap_range
#'
#' @param ldmap_range the vector of ldmap_ranges
#'
#' @export
ends <- function(ldmap_range) {
    .Call('_ldmap_ends', PACKAGE = 'ldmap', ldmap_range)
}

#' get positions from a ldmap_snp
#'
#' @param ldmap_snp the vector of SNPs
#'
#' @export
positions <- function(ldmap_snp) {
    .Call('_ldmap_positions', PACKAGE = 'ldmap', ldmap_snp)
}

#' get ref alleles from a ldmap_snp
#'
#' @param ldmap_snp the vector of SNPs
#'
#' @export
ref_alleles <- function(ldmap_snp, as_ldmap_allele = TRUE) {
    .Call('_ldmap_ref_alleles', PACKAGE = 'ldmap', ldmap_snp, as_ldmap_allele)
}

#' get ref alleles from a ldmap_snp
#'
#' @param x ldmap allele vec
#'
#' @export
format_ldmap_allele <- function(x) {
    .Call('_ldmap_format_ldmap_allele', PACKAGE = 'ldmap', x)
}

#' coerce ldmap allele to integer
#'
#' @param x ldmap_allele vec
#'
as_integer_ldmap_allele <- function(x) {
    .Call('_ldmap_as_integer_ldmap_allele', PACKAGE = 'ldmap', x)
}

#' coerce ldmap range to integer(64)
#'
#' @param x ldmap_range vec
#'
as_integer_ldmap_range <- function(x) {
    .Call('_ldmap_as_integer_ldmap_range', PACKAGE = 'ldmap', x)
}

#' migrate from old representation of ldmap_snp to new representation
#'
#' @param x ldmap_snp vec
#'
migrate_ldmap_snp <- function(x) {
    .Call('_ldmap_migrate_ldmap_snp', PACKAGE = 'ldmap', x)
}

#' migrate from new representation of ldmap_snp to old representation
#'
#' @param x ldmap_snp vec
#'
old_ldmap_snp <- function(x) {
    .Call('_ldmap_old_ldmap_snp', PACKAGE = 'ldmap', x)
}

#' get ref alleles from a ldmap_snp
#'
#' @param ldmap_snp the vector of SNPs
#'
#' @export
alt_alleles <- function(ldmap_snp, as_ldmap_allele = TRUE) {
    .Call('_ldmap_alt_alleles', PACKAGE = 'ldmap', ldmap_snp, as_ldmap_allele)
}

#' Convert ldmap snp back to dataframe
#'
#' @param ldmap_snp the vector of SNPs
#'
#' @export
ldmap_snp_2_dataframe <- function(ldmap_snp, alleles_to_character = FALSE) {
    .Call('_ldmap_ldmap_snp_2_dataframe', PACKAGE = 'ldmap', ldmap_snp, alleles_to_character)
}

#' Find SNPs that match (and find out what to do with them)
#'
#' @param query a vector of (sorted) ldmap_snps SNPs
#' @param reference a vector of (sorted) ldmap_snps SNPs
#'
#' @export
join_snp <- function(query, reference, rsid = as.integer( c())) {
    .Call('_ldmap_join_snp', PACKAGE = 'ldmap', query, reference, rsid)
}

#' Extract alternate allele from
#'
#' @param ref reference sequence (as obtained from a reference genome fasta file)
#' @param alleles_as_ambig IUPAC ambiguity codes representing alleles
#'
#' @export
extract_alt <- function(ref, alleles_as_ambig) {
    .Call('_ldmap_extract_alt', PACKAGE = 'ldmap', ref, alleles_as_ambig)
}

fast_str2int <- function(input, offset = 0L, prefix = "", na_val = NA_integer_) {
    .Call('_ldmap_fast_str2int', PACKAGE = 'ldmap', input, offset, prefix, na_val)
}

#' Create ambiguity codes from two alleles
#'
#' @param A1 allele 1
#' @param A2 allele 2
#'
#' @export
make_ambig <- function(A1, A2) {
    .Call('_ldmap_make_ambig', PACKAGE = 'ldmap', A1, A2)
}

#' Formatting method for ldmap snps
#'
#' @param x a vector of ldmap_snps
format_ldmap_snp <- function(x) {
    .Call('_ldmap_format_ldmap_snp', PACKAGE = 'ldmap', x)
}

#' Determine whether 2 alleles are compatible
#' @param query_ref_alt is a ref/alt pair
#' @param target_ref_alt is another ref/alt pair
#' @return returns a vector with 1 if the query matches the target, -1 if a flip is required, or 0 if they are incompatible;
#' @export
snp2raw <- function(input_matrix) {
    .Call('_ldmap_snp2raw', PACKAGE = 'ldmap', input_matrix)
}

#' @export
popcnt_v <- function(X, sample_size = 0) {
    .Call('_ldmap_popcnt_v', PACKAGE = 'ldmap', X, sample_size)
}

#' @export
covbin <- function(X, sample_size = 0) {
    .Call('_ldmap_covbin', PACKAGE = 'ldmap', X, sample_size)
}

#' Determine whether 2 alleles are compatible
#' @param query_ref_alt is a ref/alt pair
#' @param target_ref_alt is another ref/alt pair
#' @return returns a vector with 1 if the query matches the target, -1 if a flip is required, or 0 if they are incompatible;
#' @export
strand_flip <- function(ref_alt, reverse = FALSE) {
    .Call('_ldmap_strand_flip', PACKAGE = 'ldmap', ref_alt, reverse)
}

#' Find query SNP in a list of reference snps
#' @param query_chrom query chromosome
#' @param query_pos query position
#' @param ref_chrom reference chromosome
#' @param ref_pos reference position
#' @param query_chunk region assignment for query (optional)
#' @param ref_chunk region assignment for reference (optional)
#' @return returns a vector with the position of the match, or NA if no match is found.
#' @export
find_alleles <- function(query_chrom, query_pos, ref_chrom, ref_pos, query_chunk = as.integer( c()), ref_chunk = as.integer( c())) {
    .Call('_ldmap_find_alleles', PACKAGE = 'ldmap', query_chrom, query_pos, ref_chrom, ref_pos, query_chunk, ref_chunk)
}

#' Determine whether 2
#' @param query_ref_alt is a ref/alt pair
#' @param target_ref_alt is another ref/alt pair
#' @return returns a vector with 1 if the query matches the target, -1 if a flip is required, or 0 if they are incompatible;
#' Note that in the case that the reference and/or alternate allele are not single characters, they will only be checked for equality
#' @export
flip_alleles <- function(query_ref_alt, target_ref_alt) {
    .Call('_ldmap_flip_alleles', PACKAGE = 'ldmap', query_ref_alt, target_ref_alt)
}

