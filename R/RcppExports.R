# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Creation of new ldmap_region vector from character
#'
#' @param input a character vector
#' @export
parse_ldmap_region <- function(input) {
    .Call('_ldmap_parse_ldmap_region', PACKAGE = 'ldmap', input)
}

#' Creation of new ldmap_snp vector from character
#'
#' @param input a character vector
#' @export
parse_ldmap_SNP <- function(input) {
    .Call('_ldmap_parse_ldmap_SNP', PACKAGE = 'ldmap', input)
}

#' Linear interpolation of genetic map values
#'
#' @param map  is a length `p` vector of cumulative genetic map values. `map` must be _strictly_ _sorted_
#' @param map_pos  is a length `p` vector of genome coordinates corresponding to the reference genetic map. `map_pos` must be _strictly_ _sorted_
#' @param target_pos is a vector of coordinates to interpolate
#' @param strict a boolean indicating whether to strictly interpolate
#' @param progress a boolean indicating whether to indicate progress with a progress bar
#'
#' @export
interpolate_genetic_map <- function(map, map_pos, target_pos, strict = TRUE, progress = FALSE) {
    .Call('_ldmap_interpolate_genetic_map', PACKAGE = 'ldmap', map, map_pos, target_pos, strict, progress)
}

#' Linear interpolation of genetic map values
#'
#' @param map  is a length `p` vector of cumulative genetic map values. `map` must be _strictly_ _sorted_
#' @param map_pos  is a length `p` vector of genome coordinates corresponding to the reference genetic map. `map_pos` must be _strictly_ _sorted_
#' @param target_pos is a vector of coordinates to interpolate
#' @param strict a boolean indicating whether to strictly interpolate
#' @param progress a boolean indicating whether to indicate progress with a progress bar
#'
#' @export
new_interpolate_genetic_map <- function(map, map_pos, target_pos, strict = TRUE, progress = FALSE) {
    .Call('_ldmap_new_interpolate_genetic_map', PACKAGE = 'ldmap', map, map_pos, target_pos, strict, progress)
}

parse_hap <- function(x) {
    .Call('_ldmap_parse_hap', PACKAGE = 'ldmap', x)
}

#' New vector of haplotypes
#'
#' @param x data vector
#' @param N sample size
#' @return vector of (packed, dense) haplotypes
#' @export
new_ldmap_ht <- function(x) {
    .Call('_ldmap_new_ldmap_ht', PACKAGE = 'ldmap', x)
}

sum_ldmap_ht <- function(x) {
    .Call('_ldmap_sum_ldmap_ht', PACKAGE = 'ldmap', x)
}

dot_ht <- function(x, y) {
    .Call('_ldmap_dot_ht', PACKAGE = 'ldmap', x, y)
}

cov_ht <- function(x, y) {
    .Call('_ldmap_cov_ht', PACKAGE = 'ldmap', x, y)
}

cov_htm <- function(x, cov_2_cor = FALSE) {
    .Call('_ldmap_cov_htm', PACKAGE = 'ldmap', x, cov_2_cor)
}

ldshrink_S <- function(x, map, m = 85, Ne = 11490.672741, cutoff = 0.001, cov_2_cor = TRUE) {
    .Call('_ldmap_ldshrink_S', PACKAGE = 'ldmap', x, map, m, Ne, cutoff, cov_2_cor)
}

ht2int <- function(x) {
    .Call('_ldmap_ht2int', PACKAGE = 'ldmap', x)
}

format_ht <- function(x) {
    .Call('_ldmap_format_ht', PACKAGE = 'ldmap', x)
}

read_plink_bed_l <- function(file_name, p, N) {
    .Call('_ldmap_read_plink_bed_l', PACKAGE = 'ldmap', file_name, p, N)
}

gt_subset <- function(x, i) {
    .Call('_ldmap_gt_subset', PACKAGE = 'ldmap', x, i)
}

gt_af <- function(x, na_rm = FALSE) {
    .Call('_ldmap_gt_af', PACKAGE = 'ldmap', x, na_rm)
}

gt_afs <- function(x, na_rm = FALSE) {
    .Call('_ldmap_gt_afs', PACKAGE = 'ldmap', x, na_rm)
}

format_strings <- function(x) {
    .Call('_ldmap_format_strings', PACKAGE = 'ldmap', x)
}

#' Convert ldmap_gt to numeric vector
#'
#' @param x a vector of type ldmap_gt
#' @export
gt2double <- function(x) {
    .Call('_ldmap_gt2double', PACKAGE = 'ldmap', x)
}

#' Creation of new ldmap_regions
#'
#' @param chrom an integer vector of chromosomes
#' @param start an integer vector of start positions
#' @param stop an integer vector of stop positions
nldmap_region <- function(chrom = as.integer( c()), start = as.integer( c()), end = as.integer( c())) {
    .Call('_ldmap_nldmap_region', PACKAGE = 'ldmap', chrom, start, end)
}

#' Quickly calculate distance between to ldmap_regions
#'
#' @param query vector of query ldmap_snps
#' @param target vector of target ldmap_regions (must be sorted)
#' @return a vector of integers with the length between the two ranges
#' @export distance.ldmap_region.ldmap_region
#' @method distance.ldmap_region ldmap_region
#' @export
distance.ldmap_region.ldmap_region <- function(query, target) {
    .Call('_ldmap_distance_ldmap_region_ldmap_region', PACKAGE = 'ldmap', query, target)
}

#' Quickly calculate distance between to ldmap_regions
#'
#' @param query vector of query ldmap_snps
#' @param target vector of target ldmap_regions (must be sorted)
#' @return a vector of integers with the length between the two ranges
#' @export distance.ldmap_region.ldmap_snp
#' @method distance.ldmap_region ldmap_snp
#' @export
distance.ldmap_region.ldmap_snp <- function(query, target) {
    .Call('_ldmap_distance_ldmap_region_ldmap_snp', PACKAGE = 'ldmap', query, target)
}

#' Quickly calculate distance between to ldmap_regions
#'
#' @param query vector of query ldmap_snps
#' @param target vector of target ldmap_regions (must be sorted)
#' @return a vector of integers with the length between the two ranges
#' @export distance.ldmap_snp.ldmap_region
#' @method distance.ldmap_snp ldmap_region
#' @export
distance.ldmap_snp.ldmap_region <- function(query, target) {
    .Call('_ldmap_distance_ldmap_snp_ldmap_region', PACKAGE = 'ldmap', query, target)
}

#' Quickly calculate distance between to ldmap_regions
#'
#' @param query vector of query ldmap_snps
#' @param target vector of target ldmap_regions (must be sorted)
#' @return a vector of integers with the length between the two ranges
#' @export distance.ldmap_snp.ldmap_snp
#' @method distance.ldmap_snp ldmap_snp
#' @export
distance.ldmap_snp.ldmap_snp <- function(query, target) {
    .Call('_ldmap_distance_ldmap_snp_ldmap_snp', PACKAGE = 'ldmap', query, target)
}

#' Assign ldmap_regions into non-overlapping groups (
#'
#' @param query vector of type ldmap_region
#' @export
group_regions <- function(query) {
    .Call('_ldmap_group_regions', PACKAGE = 'ldmap', query)
}

#' Assign ranges to nearest ranges
#'
#' @param query vector of query ldmap_snps
#' @param target vector of target ldmap_regions (must be sorted)
#' @param use_begin logical scalar indicating whether to use the start of the target range(TRUE), the end(FALSE), or them min distance of the two (NA_LOGICAL)
#' @param max_dist integer giving the maximum allowable distance for assignment
#' @return a vector of integers of length `length(ldmap_region_query)` with the index of the `ldmap_region_target` (or NA_INTEGER if there is no overlap in the set of chromosomes)
#' @export
nearest_snp_region <- function(query, target, max_dist = NA_integer_) {
    .Call('_ldmap_nearest_snp_region', PACKAGE = 'ldmap', query, target, max_dist)
}

#' Assign ranges to ranges
#'
#' @param ldmap_region_query vector of ldmap_regions
#' @param ldmap_region_target vector of *non-overlapping* ldmap_regions (must be sorted)
#' @param allow_overlap is it alright if a query is only partially inside the target?
#' @return a vector of integers of length `length(ldmap_region_query)` with the index of the `ldmap_region_target`
#' @export
region_in_region <- function(ldmap_region_query, ldmap_region_target, allow_overlap = FALSE) {
    .Call('_ldmap_region_in_region', PACKAGE = 'ldmap', ldmap_region_query, ldmap_region_target, allow_overlap)
}

#' Assign SNPs to ranges
#'
#' @param ldmap_snp vector of ldmap_snps (must be sorted)
#' @param ldmap_region vector of non-overlapping ldmap_regions (must be sorted)
#' @return a vector of integers of length `length(ldmap_snp)` with the index of the `ldmap_region`
#' @export
snp_in_region <- function(ldmap_snp, ldmap_region) {
    .Call('_ldmap_snp_in_region', PACKAGE = 'ldmap', ldmap_snp, ldmap_region)
}

#' Check SNPs for positional equality
#'
#' @param x vector of query ldmap_snps
#' @param y vector of target ldmap_snps
#' @return a vector of integers of length `x` that indexes into `y`
#' @export
snp_overlap_snp <- function(x, y) {
    .Call('_ldmap_snp_overlap_snp', PACKAGE = 'ldmap', x, y)
}

#' Assign SNPs to ranges
#'
#' @param ldmap_snp vector of ldmap_snps (must be sorted)
#' @param ldmap_region vector of non-overlapping ldmap_regions (must be sorted)
#' @return a vector of integers of length `length(ldmap_snp)` with the index of the `ldmap_region`
#' @export
region_overlap_snp <- function(ldmap_region, ldmap_snp) {
    .Call('_ldmap_region_overlap_snp', PACKAGE = 'ldmap', ldmap_region, ldmap_snp)
}

#' Assign SNPs to ranges
#'
#' @param ldmap_snp vector of ldmap_snps (must be sorted)
#' @param ldmap_region vector of non-overlapping ldmap_regions (must be sorted)
#' @return a vector of integers of length `length(ldmap_snp)` with the index of the `ldmap_region`
#' @export
snp_in_regions <- function(ldmap_snp, ldmap_regions) {
    .Call('_ldmap_snp_in_regions', PACKAGE = 'ldmap', ldmap_snp, ldmap_regions)
}

#' formatting of ldmap_regions
#'
#' @param x an ldmap_region
#' @export
format_ldmap_region <- function(x) {
    .Call('_ldmap_format_ldmap_region', PACKAGE = 'ldmap', x)
}

#' Assign SNPs to ranges
#'
#' @param ldmap_snp vector of ldmap_snps (must be sorted)
#' @param ldmap_region vector of potentially overlapping ldmap_regions (must be sorted)
#' @return a list of integer vectors giving the ranges to which each SNP belongs
#' @export
match_regions_snps <- function(df, ldmap_region, snp_col = "snp_struct") {
    .Call('_ldmap_match_regions_snps', PACKAGE = 'ldmap', df, ldmap_region, snp_col)
}

#' Create overlapping regions based on monotonic, point-level annotation
#'
#' @param ldmap_snp a (sorted) ldmap_snp vector (`length(ldmap_snp)` is referred to  as  `p`)
#' @param cm a numeric vector of (length `p`) per-snp annotations (e.g cumulative recombination rate)
#' @param window the window width.
#'
#' @return a vector of `ldmap_region`s of length `p` giving the window for each SNP.  The width of the window
#' is defined for a target snp `ldmap_snp[i]`, as having the chromosome
#' from `ldmap_snp[i]` and including the position of all `ldmap_snp[j]` snps such that `abs(cm[i]-cm[j])<window` for all values of `j`
#' @export
window_ldmap_region <- function(ldmap_snp, cm, window = 1.0) {
    .Call('_ldmap_window_ldmap_region', PACKAGE = 'ldmap', ldmap_snp, cm, window)
}

#' Take a vector of (preferably) sorted and (possibly) overlapping ldmap_regions and create a new range of (sorted) non-overlapping ldmap_regions
#'
#' @param x a (preferably sorted) ldmap_region vector (`length(x)` is referred to  as  `p`)
#'
#' @export
#' @return a sorted vector ldmap_regions of length at least `p` and at most `2p`(?) representing the same intervals
split_ldmap_region_overlap <- function(x) {
    .Call('_ldmap_split_ldmap_region_overlap', PACKAGE = 'ldmap', x)
}

#' Merge two ldmap_region vectors
#'
#' @param x a (preferably sorted) ldmap_region vector (`length(x)` is referred to  as  `p`)
#' @param y a (preferably sorted) ldmap_region vector (`length(y)` is referred to  as  `q`)
#'
#' @return a sorted vector ldmap_regions of length at most `p+q` and at least `max(p,q)` representing the union of the two sets of ranges
#' @export
merge_ldmap_regions <- function(x, y) {
    .Call('_ldmap_merge_ldmap_regions', PACKAGE = 'ldmap', x, y)
}

#' convert ldmap_region to dataframe
#'
#' @param ldmap_region an ldmap_region
#' @export
ldmap_region_2_data_frame <- function(ldmap_region) {
    .Call('_ldmap_ldmap_region_2_data_frame', PACKAGE = 'ldmap', ldmap_region)
}

#' Creation of new ldmap_snps
#'
#' @param chrom an integer vector of chromosomes
#' @param pos a double vector of positions
#' @param ref an optional vector of reference allele (see `?new_ldmap_allele`)
#' @param alt an optional vector of alternate allele (see `?new_ldmap_allele`)
#' @param NA2N an optional boolean specifying whether missing/NA alleles should be treated as "N"
#'
new_ldmap_snp_impl <- function(chrom, pos, ref, alt, NA2N = FALSE) {
    .Call('_ldmap_new_ldmap_snp_impl', PACKAGE = 'ldmap', chrom, pos, ref, alt, NA2N)
}

sample_interval <- function(n, beginv, endv, replace = FALSE) {
    .Call('_ldmap_sample_interval', PACKAGE = 'ldmap', n, beginv, endv, replace)
}

#' Which SNPs are strand ambiguous
#'
#' @param x the ldmap_snp struct
#'
#' @export
is_strand_ambiguous <- function(x) {
    .Call('_ldmap_is_strand_ambiguous', PACKAGE = 'ldmap', x)
}

#' Convert allele info to ldmap_alleles
#'
#' @param allele vector of alleles, coded either as character, integer or raw
#'
#' @export
new_ldmap_allele <- function(allele = as.integer( c())) {
    .Call('_ldmap_new_ldmap_allele', PACKAGE = 'ldmap', allele)
}

#' sorting method for ldmap snps
#'
#' @param struct_vec the vector of SNPs
#'
#' @method order ldmap_snp
#' @export
#' @export order.ldmap_snp
order.ldmap_snp <- function(struct_vec) {
    .Call('_ldmap_order_snps', PACKAGE = 'ldmap', struct_vec)
}

#' ranking method for ldmap snps
#'
#' @param struct_vec the vector of SNPs
#'
#' @method rank ldmap_snp
#' @export
#' @export rank.ldmap_snp
rank.ldmap_snp <- function(struct_vec) {
    .Call('_ldmap_rank_snps', PACKAGE = 'ldmap', struct_vec)
}

#' get chroms from a ldmap_snp
#'
#' @param struct_vec the vector of SNPs (or ldmap_regions)
#'
#' @export
chromosomes <- function(struct_vec) {
    .Call('_ldmap_chromosomes', PACKAGE = 'ldmap', struct_vec)
}

#' get starting position from a ldmap_region
#'
#' @param ldmap_region the vector of ldmap_regions
#'
#' @export
starts <- function(ldmap_region) {
    .Call('_ldmap_starts', PACKAGE = 'ldmap', ldmap_region)
}

#' Find convex hull of vector of ranges (or SNPs )
#'
#' @param vector of ldmap_region or ldmap_snp of
#' @return an ldmap range containg all the ranges (or snps)
#'
#' @export
convex_hull <- function(x) {
    .Call('_ldmap_convex_hull', PACKAGE = 'ldmap', x)
}

#' get end position from a ldmap_region
#'
#' @param ldmap_region the vector of ldmap_regions
#'
#' @export
ends <- function(ldmap_region) {
    .Call('_ldmap_ends', PACKAGE = 'ldmap', ldmap_region)
}

#' get positions from a ldmap_snp
#'
#' @param ldmap_snp the vector of SNPs
#'
#' @export
positions <- function(ldmap_snp) {
    .Call('_ldmap_positions', PACKAGE = 'ldmap', ldmap_snp)
}

#' get ref alleles from a ldmap_snp
#'
#' @param ldmap_snp the vector of SNPs
#'
#' @export
ref_alleles <- function(ldmap_snp, as_ldmap_allele = TRUE) {
    .Call('_ldmap_ref_alleles', PACKAGE = 'ldmap', ldmap_snp, as_ldmap_allele)
}

#' get ref alleles from a ldmap_snp
#'
#' @param x ldmap allele vec
#'
#' @export
format_ldmap_allele <- function(x) {
    .Call('_ldmap_format_ldmap_allele', PACKAGE = 'ldmap', x)
}

#' coerce ldmap allele to integer
#'
#' @param x ldmap_allele vec
#'
as_integer_ldmap_allele <- function(x) {
    .Call('_ldmap_as_integer_ldmap_allele', PACKAGE = 'ldmap', x)
}

#' coerce ldmap range to integer(64)
#'
#' @param x ldmap_region vec
#'
as_integer_ldmap_region <- function(x) {
    .Call('_ldmap_as_integer_ldmap_region', PACKAGE = 'ldmap', x)
}

#' migrate from old representation of ldmap_snp to new representation
#'
#' @param x ldmap_snp vec
#'
migrate_ldmap_snp <- function(x) {
    .Call('_ldmap_migrate_ldmap_snp', PACKAGE = 'ldmap', x)
}

#' migrate from new representation of ldmap_snp to old representation
#'
#' @param x ldmap_snp vec
#'
old_ldmap_snp <- function(x) {
    .Call('_ldmap_old_ldmap_snp', PACKAGE = 'ldmap', x)
}

#' get ref alleles from a ldmap_snp
#'
#' @param ldmap_snp the vector of SNPs
#'
#' @export
alt_alleles <- function(ldmap_snp, as_ldmap_allele = TRUE) {
    .Call('_ldmap_alt_alleles', PACKAGE = 'ldmap', ldmap_snp, as_ldmap_allele)
}

#' Convert ldmap snp back to dataframe
#'
#' @param ldmap_snp the vector of SNPs
#'
#' @export
ldmap_snp_2_dataframe <- function(ldmap_snp, alleles_to_character = FALSE) {
    .Call('_ldmap_ldmap_snp_2_dataframe', PACKAGE = 'ldmap', ldmap_snp, alleles_to_character)
}

#' For SNPs with equal chromosome and position, do the alleles match?
#'
#' @param query a vector of (sorted) ldmap_snps SNPs
#' @param reference a vector of (sorted) ldmap_snps SNPs
#'
#' @export
allele_match <- function(query, reference) {
    .Call('_ldmap_allele_match', PACKAGE = 'ldmap', query, reference)
}

#' Find SNPs that match (and find out what to do with them)
#'
#' @param query a vector of (sorted) ldmap_snps SNPs
#' @param reference a vector of (sorted) ldmap_snps SNPs
#'
#' @export
join_snp <- function(query, reference, rsid = as.integer( c())) {
    .Call('_ldmap_join_snp', PACKAGE = 'ldmap', query, reference, rsid)
}

#' Extract alternate allele from
#'
#' @param ref reference sequence (as obtained from a reference genome fasta file)
#' @param alleles_as_ambig IUPAC ambiguity codes representing alleles
#'
#' @export
extract_alt <- function(ref, alleles_as_ambig) {
    .Call('_ldmap_extract_alt', PACKAGE = 'ldmap', ref, alleles_as_ambig)
}

fast_str2int <- function(input, offset = 0L, prefix = "", na_val = NA_integer_) {
    .Call('_ldmap_fast_str2int', PACKAGE = 'ldmap', input, offset, prefix, na_val)
}

#' Create ambiguity codes from two alleles
#'
#' @param A1 allele 1
#' @param A2 allele 2
#'
#' @export
make_ambig <- function(A1, A2) {
    .Call('_ldmap_make_ambig', PACKAGE = 'ldmap', A1, A2)
}

#' Formatting method for ldmap snps
#'
#' @param x a vector of ldmap_snps
format_ldmap_snp <- function(x) {
    .Call('_ldmap_format_ldmap_snp', PACKAGE = 'ldmap', x)
}

#' Split a vector ldmap_regions into non-overlapping groups
#'
#' @param x a vector of ldmap_snps
#' @export
split_by_overlap <- function(x) {
    .Call('_ldmap_split_by_overlap', PACKAGE = 'ldmap', x)
}

#' Determine whether 2 alleles are compatible
#' @param query_ref_alt is a ref/alt pair
#' @param target_ref_alt is another ref/alt pair
#' @return raw matrix
#' @export
snp2raw <- function(input_matrix) {
    .Call('_ldmap_snp2raw', PACKAGE = 'ldmap', input_matrix)
}

#' @export
popcnt_v <- function(X, sample_size = 0) {
    .Call('_ldmap_popcnt_v', PACKAGE = 'ldmap', X, sample_size)
}

#' @export
covbin <- function(X, sample_size = 0) {
    .Call('_ldmap_covbin', PACKAGE = 'ldmap', X, sample_size)
}

#' Determine whether 2 alleles are compatible
#' @param query_ref_alt is a ref/alt pair
#' @param target_ref_alt is another ref/alt pair
#' @return returns a vector with 1 if the query matches the target, -1 if a flip is required, or 0 if they are incompatible;
#' @export
strand_flip <- function(ref_alt, reverse = FALSE) {
    .Call('_ldmap_strand_flip', PACKAGE = 'ldmap', ref_alt, reverse)
}

#' Find query SNP in a list of reference snps
#' @param query_chrom query chromosome
#' @param query_pos query position
#' @param ref_chrom reference chromosome
#' @param ref_pos reference position
#' @param query_chunk region assignment for query (optional)
#' @param ref_chunk region assignment for reference (optional)
#' @return returns a vector with the position of the match, or NA if no match is found.
#' @export
find_alleles <- function(query_chrom, query_pos, ref_chrom, ref_pos, query_chunk = as.integer( c()), ref_chunk = as.integer( c())) {
    .Call('_ldmap_find_alleles', PACKAGE = 'ldmap', query_chrom, query_pos, ref_chrom, ref_pos, query_chunk, ref_chunk)
}

#' Determine whether 2
#' @param query_ref_alt is a ref/alt pair
#' @param target_ref_alt is another ref/alt pair
#' @return returns a vector with 1 if the query matches the target, -1 if a flip is required, or 0 if they are incompatible;
#' Note that in the case that the reference and/or alternate allele are not single characters, they will only be checked for equality
#' @export
flip_alleles <- function(query_ref_alt, target_ref_alt) {
    .Call('_ldmap_flip_alleles', PACKAGE = 'ldmap', query_ref_alt, target_ref_alt)
}

